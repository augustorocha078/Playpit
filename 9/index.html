<html>
<head>
	<meta charset="UTF-8">
	<title>first canvas</title>
	<script src="/common/js/Three.js" type="text/javascript" ></script>
	
	<script src="/common/js/Detector.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/utils/Stats.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/RequestAnimationFrame.js" type="text/javascript"></script>
	<script src="/common/js/utils/noise.js" type="text/javascript" charset="utf-8"></script>
	
	<script src="/common/js/gui/gui.full.js" type="text/javascript" charset="utf-8"></script>
	
	
	<script src="/common/js/ShaderExtras.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/RenderPass.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/ShaderPass.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/TexturePass.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/EffectComposer.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/MaskPass.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/BloomPass.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/DotScreenPass.js" type="text/javascript" charset="utf-8"></script>
	<script src="/common/js/postprocessing_dev/FilmPass.js" type="text/javascript" charset="utf-8"></script>
	
	
	<style>
	 body{
		margin:0;
		padding:0;
		background-color:#ffffff;
		overflow: hidden;	
	}
	</style>
	<link rel="stylesheet" href="../common/js/gui/gui.css" type="text/css" media="screen" title="no title" charset="utf-8">
	
</head>

<body>
	<script type="text/javascript">

				var container, camera, scene, renderer;
				var target, cTarget;
				var particleGeometry,	particles, particleMaterials;

			    var composerScene;

				var lineGeometry, lineMaterial, line;
				var lineColors = new Array();
				var colors = [ 0xefb3bb, 0x96d7eb, 0xb4b4b4, 0x75a3b0, 0xa08189 ];

				var particlePositions = new Array();
				var oldPositions = new Array();
				var vVectors = new Array();

				var rotationSpeed = 0;

				var tVector = new THREE.Vector3(-10,0,0);
				var mrx = 0;
				var mry = 0;
				var speedMultiply = 1.00;

				var stageWidth = 500;
				var stageHeight = 500;
				var mx=0;
				var my=0;

				var pi = Math.PI;

				var areaLength = 1200;
				var particleR = 15;
				var particleNum = 1000;
				var strokeNum = 30;
				
				//for depth of field
				var rtTextureDepth, rtTextureColor, materialDepth

				function init(){

					if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

					stageWidth = window.innerWidth;
					stageHeight = window.innerHeight;

					//container
					container = document.createElement('div');
					document.body.appendChild(container);

					//scene
					scene = new THREE.Scene();
					scene.fog = new THREE.Fog( 0xffffff, 1, areaLength);

					//camera
					camera = new THREE.PerspectiveCamera( 75, stageWidth/stageHeight, 1, 1200);
					scene.add(camera);

					//target
					cTarget = new THREE.Object3D();
					target = new THREE.Object3D();

					scene.add(cTarget);
					scene.add(target);


					//renderer
					renderer = new THREE.WebGLRenderer( { antialias:false } );
					renderer.setSize( stageWidth, stageHeight);
					renderer.setClearColorHex(0xffffff, 1);
					renderer.autoClear = false;
//					renderer.sortObjects = false	;
					container.appendChild( renderer.domElement );


					//for postprocessing
					pScene = new THREE.Scene();
					pCamera = new THREE.OrthographicCamera( stageWidth / - 2, stageWidth / 2,  stageHeight / 2, stageHeight/ - 2, -10000, 10000 );
					pCamera.position.z = 100;
					material_depth = new THREE.MeshDepthMaterial();

					//vignette
					var shaderVignette = THREE.ShaderExtras[ "vignette" ];
					var effectVignette = new THREE.ShaderPass( shaderVignette );
					effectVignette.uniforms["offset"].value = 0.50;
					effectVignette.uniforms["darkness"].value = 1.5;
					effectVignette.renderToScreen = true;
					
					var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
					rtTextureColor = new THREE.WebGLRenderTarget( stageWidth, stageHeight, pars, true );
					rtTextureDepth = new THREE.WebGLRenderTarget( stageWidth, stageHeight, pars, true );
					
					//bokeh
					var shaderBokeh = THREE.ShaderExtras[ "bokeh" ];
					var effectBokeh = new THREE.ShaderPass( shaderBokeh );
					effectBokeh.uniforms[ "tColor" ].texture = rtTextureColor;
					effectBokeh.uniforms[ "tDepth" ].texture = rtTextureDepth;
					effectBokeh.uniforms["focus"].value = 1.1;
					effectBokeh.uniforms[ "aspect" ].value = stageWidth / stageHeight;
					
					pMaterialBokeh = new THREE.ShaderMaterial( {

						uniforms: effectBokeh.uniforms,
						vertexShader: shaderBokeh.vertexShader,
						fragmentShader: shaderBokeh.fragmentShader

					} );

					quad = new THREE.Mesh( new THREE.PlaneGeometry( window.innerWidth, window.innerHeight ), pMaterialBokeh );
					quad.position.z = - 500;
					pScene.add( quad );


					var renderModel = new THREE.RenderPass( scene, camera );
					var renderTargetParameter = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBufer: true, depthBuffer:true };
					var renderTarget = new THREE.WebGLRenderTarget(stageWidth, stageHeight, renderTargetParameter);

					composerScene = new THREE.EffectComposer( renderer,  renderTarget);
					composerScene.addPass( renderModel );
					composerScene.addPass( effectVignette );


					//Material
					var texture = THREE.ImageUtils.loadTexture( "/9/textures/100px_circle.png");
					particleMaterial = new THREE.ParticleBasicMaterial({
						color:0xffffff,
						map:texture,
						blending:THREE.Normal,
						size:particleR,
						transparent:true
					});

					lineMaterial = new THREE.LineBasicMaterial({
							vertexColors:true,
							color:0xffffff,
							blending:THREE.AdditiveBlending,
							opacity: 1.0,//0.1,
							lineWidth:1
						});

					//create particles
					particleGeometry = new THREE.Geometry();
					lineGeometry = new THREE.Geometry();

					for( var i=0; i<particleNum; i++){

						//create vectors;
						vVectors[i] = new THREE.Vector3( 0, 0, 0);
						particlePositions[i] = new THREE.Vector3(areaLength*(Math.random()*2-1), -200, areaLength*(Math.random()*2-1));
						particleGeometry.vertices.push( new THREE.Vertex(particlePositions[i]));

						for( var j=0; j<strokeNum; j++){
							oldPositions.push(new Array());
							oldPositions[i].push(particlePositions[i].clone());
							lineGeometry.vertices.push( new THREE.Vertex(oldPositions[i][j]) );

							var lc = new THREE.Color( colors[i%colors.length] );
							if(j>0){
								lineColors.push( lc );
								lineColors.push( lc );
							}
						}
					}

					particles = new THREE.ParticleSystem( particleGeometry, particleMaterial );
					//particles.sortParticles = true;
					scene.add( particles );


					line = new THREE.Line( lineGeometry, lineMaterial, THREE.LinePieces );
					line.colors = lineColors;
					scene.add( line );


					//event
					document.addEventListener('mousemove', mouseMove);
					document.addEventListener('click', mouseClick);
					window.addEventListener('resize', resize, false);

					animate();



				}


				function mouseClick (e) {
					if(speedMultiply<10)	speedMultiply *= 1.5;
				}

				function resize(){
					stageWidth = window.innerWidth;
					stageHeight = window.innerHeight;
					camera.aspect =  stageWidth/stageHeight;
					renderer.setSize(stageWidth, stageHeight)
				//	camera.updateProjectionMatrix();
				}

				function mouseMove(ev){
					omx = mx;
					omy = my;
					mx = ev.clientX - window.innerWidth/2;
					my = ev.clientY - window.innerHeight/2;
					mrx = 0.008*(mx)*pi/180;
					mry = 0.008*(my)*pi/180;
				}

				function animate(){
					requestAnimationFrame(animate);

					update();

					renderer.clear();
					
					//color
					// scene.overrideMaterial = null;
					// renderer.render( scene, camera, rtTextureColor, true);
					// //depth
					// scene.overrideMaterial = material_depth;
					// renderer.render( scene, camera, rtTextureDepth, true);
					// renderer.render( scene, camera);
					composerScene.render();
					//renderer.render(scene, camera)


				}


				var cnt = 0;
				var t1=0, t2=0;

		//////////////////////////////	//////////////////////////////	//////////////////////////////	


				function update(){

					//refresh line
					var refreshLine = (cnt%2==0);
					if(refreshLine){
						scene.remove( line );
						lineGeometry = new THREE.Geometry();
					}

					//target vector
					var svec = tVector.clone();
					svec = svec.multiplyScalar(speedMultiply);
					target.position.addSelf( svec );
					speedMultiply += (1-speedMultiply)/(60+speedMultiply);

					//camera
					var cvec = target.position.clone();
					cvec.z += 1000;
					camera.position = cvec;

					var cmtx1 = new THREE.Matrix4();
					cmtx1.setTranslation(-0,0,200);
					var cmtrx = new THREE.Matrix4();
					cmtrx.setRotationX( Math.cos(cnt*pi/180) );
					var cmtry = new THREE.Matrix4();
					cmtry.setRotationY( Math.sin(cnt*pi/180) );
					var cmtx2 = new THREE.Matrix4();
					cmtx2.setPosition( target.position );
					var mm = cmtrx.multiplySelf(cmtx1);
					mm = cmtry.multiplySelf(cmtrx);
					mm = cmtx2.multiplySelf(cmtry);
					cTarget.position = mm.getPosition();
					// cTarget.position = target.position;

					camera.lookAt(cTarget);


					//particles
					var vertices = [];
					var speed = 1.0;
					t1+=0.024;
					t2+=0.008;

					for(var i=0; i<particleNum; i++){

						var ptcl = particleGeometry.vertices[i];
						var ps = particlePositions[i];
						var v = vVectors[i];

						//noise
						var resultX = fBm2d( t1+ps.x / stageWidth, t1+ps.y/stageHeight, 1);
						var resultY = fBm2d( ps.x / stageWidth,  ps.z/stageHeight*0.5, 1);
						var resultZ = fBm2d( t2+ps.x / stageWidth, t2+ps.y/stageHeight, 1);
						v.x += resultX*1.5*speedMultiply;
						v.y += resultY*1.5*speedMultiply;
						v.z += resultZ*3.5*speedMultiply;
						
						v.x += (0-v.x)/10;
						v.y += (0-v.y)/10;
						v.z += (0-v.z)/10;
						
						ps.addSelf(v);
						ps.addSelf( tVector );
						
						ps.y += (resultY*500-100 -ps.y)/20;

						//matrix
						//position
						var mtx = new THREE.Matrix4();
						mtx.setPosition( ps );

						ptcl.position = mtx.getPosition();

						if(refreshLine){
							oldPositions[i].unshift(ps.clone());
							oldPositions[i].pop();

							for( var j=0; j<strokeNum-1; j++){
								vertices.push( new THREE.Vertex( oldPositions[i][j] ) );
								vertices.push( new THREE.Vertex( oldPositions[i][j+1] ) );
							}
						}				
						
						//wrapping point
						if(ps.x>areaLength+target.position.x){ 
							ps.x = -areaLength + Math.random()*100;
							ps.z = (Math.random()*2-1)*areaLength;
							ps.addSelf(target.position);
							for(var j=0; j<strokeNum; j++) oldPositions[i][j]= ps.clone();
						};
						if(ps.x<-areaLength+target.position.x) {
							ps.x = areaLength - Math.random()*100;
							ps.z = (Math.random()*2-1)*areaLength;
							ps.addSelf(target.position);
							for(var j=0; j<strokeNum; j++) oldPositions[i][j]= ps.clone();
						}
						if(ps.z>areaLength+target.position.z){
							ps.z = -areaLength + Math.random()*100;
							ps.x = (Math.random()*2-1)*areaLength;
							ps.addSelf(target.position);
							for(var j=0; j<strokeNum; j++) oldPositions[i][j]= ps.clone();
						} 
						if(ps.z<-areaLength+target.position.z) {
							ps.z = -areaLength - Math.random()*100;
							ps.x = (Math.random()*2-1)*areaLength;
							ps.addSelf(target.position);
							for(var j=0; j<strokeNum; j++) oldPositions[i][j]= ps.clone();
						}
						
					}

					//draw lines
					if(refreshLine){
						lineGeometry.vertices = vertices;
						lineGeometry.colors = lineColors;
						line = new THREE.Line( lineGeometry, lineMaterial, THREE.LinePieces );
						scene.add( line );
					}

					cnt++;



				}

				///////////////////////////////////////////

		init();
	</script>
</body>
</html>